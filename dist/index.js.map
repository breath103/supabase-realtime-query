{"version":3,"sources":["../src/index.ts","../src/repository.ts","../src/query-keys.ts","../src/types.ts","../src/context.tsx","../src/hooks.tsx","../src/realtime.ts","../src/server.ts"],"sourcesContent":["// Core\nexport { Repository, type RepositoryConfig, type FilterBuilder } from \"./repository\";\n\n// Types\nexport {\n  type DatabaseSchema,\n  type TableNames,\n  type TableRow,\n  type TableInsert,\n  type TableUpdate,\n  type TableID,\n  type RealtimeEvent,\n  type Sort,\n  sort\n} from \"./types\";\n\n// Query keys\nexport { recordQueryKey, recordListQueryKey, recordByIdsQueryKey } from \"./query-keys\";\n\n// React context\nexport { createRepositoryContext } from \"./context\";\n\n// React hooks\nexport {\n  useRecordById,\n  useRecordByIds,\n  useRecordListQuery,\n  useUpdateRecord,\n  useDeleteRecord\n} from \"./hooks\";\n\n// Realtime\nexport { createRealtimeChannel, type RealtimeChannelConfig } from \"./realtime\";\n\n// Server utilities\nexport { prefetchRecordById } from \"./server\";\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { type PostgrestFilterBuilder } from \"@supabase/postgrest-js\";\nimport { type SupabaseClient } from \"@supabase/supabase-js\";\nimport { QueryClient } from \"@tanstack/react-query\";\nimport { Observable, Subscription } from \"rxjs\";\n\nimport { recordQueryKey } from \"./query-keys\";\nimport { DatabaseSchema, RealtimeEvent, TableNames, TableRow, TableUpdate } from \"./types\";\n\n/**\n * Filter builder type for query construction.\n * Uses `any` for schema to avoid complex type constraints from postgrest-js.\n */\nexport type FilterBuilder<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n> = PostgrestFilterBuilder<\n  any,\n  any,\n  TableRow<TDatabase, TSchema, TTable>,\n  TableRow<TDatabase, TSchema, TTable>[],\n  unknown,\n  unknown,\n  \"GET\"\n>;\n\n/**\n * Configuration for creating a Repository\n */\nexport type RepositoryConfig<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase\n> = {\n  supabase: SupabaseClient<TDatabase>;\n  schema: TSchema;\n  events$: Observable<RealtimeEvent<TableNames<TDatabase, TSchema>, any>>;\n};\n\n/**\n * Repository - manages Supabase data with React Query caching and realtime updates\n */\nexport class Repository<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase\n> {\n  public readonly queryClient: QueryClient;\n  private readonly supabase: SupabaseClient<TDatabase>;\n  private readonly schema: TSchema;\n  private readonly subscription: Subscription;\n\n  constructor(config: RepositoryConfig<TDatabase, TSchema>) {\n    this.supabase = config.supabase;\n    this.schema = config.schema;\n\n    this.queryClient = new QueryClient({\n      defaultOptions: {\n        queries: {\n          refetchOnMount: false,\n          refetchOnWindowFocus: false,\n          refetchInterval: false,\n          refetchOnReconnect: false,\n          staleTime: Infinity,\n          gcTime: Infinity\n        }\n      }\n    });\n\n    // Subscribe to realtime events and update cache\n    this.subscription = config.events$.subscribe((payload) => {\n      const table = payload.table;\n\n      if (payload.operation === \"INSERT\") {\n        this.queryClient.setQueryData(\n          recordQueryKey(table, payload.record.id),\n          payload.record\n        );\n      } else if (payload.operation === \"UPDATE\") {\n        this.queryClient.setQueryData(\n          recordQueryKey(table, payload.record.id),\n          payload.record\n        );\n      } else if (payload.operation === \"DELETE\") {\n        this.queryClient.removeQueries({\n          queryKey: recordQueryKey(table, payload.old_record.id)\n        });\n      }\n    });\n  }\n\n  /**\n   * Get a record from cache by ID (does not fetch)\n   */\n  getRecordByIdFromCache<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    id: TableRow<TDatabase, TSchema, TTable>[\"id\"] | null\n  ): TableRow<TDatabase, TSchema, TTable> | null | undefined {\n    if (id === null) return null;\n    return this.queryClient.getQueryData(recordQueryKey(table, id));\n  }\n\n  /**\n   * Create a new record\n   */\n  async createRecord<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    insert: Partial<TableRow<TDatabase, TSchema, TTable>>\n  ) {\n    const response = await (this.supabase as any)\n      .schema(this.schema)\n      .from(table)\n      .insert(insert);\n    return this.throwIfError(response);\n  }\n\n  /**\n   * Update an existing record\n   */\n  async updateRecord<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    id: TableRow<TDatabase, TSchema, TTable>[\"id\"],\n    update: Partial<TableUpdate<TDatabase, TSchema, TTable>>\n  ) {\n    const response = await (this.supabase as any)\n      .schema(this.schema)\n      .from(table)\n      .update(update)\n      .eq(\"id\", id);\n    return this.throwIfError(response);\n  }\n\n  /**\n   * Delete a record\n   */\n  async deleteRecord<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    id: TableRow<TDatabase, TSchema, TTable>[\"id\"]\n  ) {\n    const response = await (this.supabase as any)\n      .schema(this.schema)\n      .from(table)\n      .delete()\n      .eq(\"id\", id);\n    return this.throwIfError(response);\n  }\n\n  /**\n   * Get a single record by ID\n   */\n  async getRecordById<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    id: TableRow<TDatabase, TSchema, TTable>[\"id\"]\n  ): Promise<TableRow<TDatabase, TSchema, TTable> | null> {\n    const response = await (this.supabase as any)\n      .schema(this.schema)\n      .from(table)\n      .select()\n      .eq(\"id\", id)\n      .maybeSingle();\n    return this.throwIfError(response);\n  }\n\n  /**\n   * Get multiple records by IDs\n   */\n  async getRecordByIds<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    ids: TableRow<TDatabase, TSchema, TTable>[\"id\"][]\n  ): Promise<TableRow<TDatabase, TSchema, TTable>[]> {\n    if (ids.length === 0) return [];\n    const response = await (this.supabase as any)\n      .schema(this.schema)\n      .from(table)\n      .select()\n      .in(\"id\", ids);\n    return this.throwIfError(response);\n  }\n\n  /**\n   * Get records with a custom query, caching each result\n   */\n  async getRecords<TTable extends TableNames<TDatabase, TSchema>>(\n    table: TTable,\n    query: (filter: FilterBuilder<TDatabase, TSchema, TTable>) => FilterBuilder<TDatabase, TSchema, TTable>\n  ): Promise<TableRow<TDatabase, TSchema, TTable>[]> {\n    const baseQuery = (this.supabase as any).schema(this.schema).from(table).select();\n    const response = await query(baseQuery);\n    const records = this.throwIfError(response) as TableRow<TDatabase, TSchema, TTable>[];\n\n    // Cache individual records\n    records.forEach((item) => {\n      this.queryClient.setQueryData(recordQueryKey(table, (item as any).id), item);\n    });\n\n    return records;\n  }\n\n  private throwIfError<T>(response: { data: T; error: null } | { data: null; error: Error }): T {\n    if (response.error) throw response.error;\n    return response.data;\n  }\n\n  /**\n   * Clean up subscriptions and cache\n   */\n  destroy() {\n    this.subscription.unsubscribe();\n    this.queryClient.clear();\n  }\n}\n","/**\n * Query key factory for consistent cache key generation\n */\nexport function recordQueryKey(table: string, id: string | number) {\n  return [table, id] as const;\n}\n\nexport function recordListQueryKey(table: string, listName: string) {\n  return [table, \"list\", listName] as const;\n}\n\nexport function recordByIdsQueryKey(table: string, ids: (string | number)[]) {\n  return [table, \"byIds\", [...ids].sort().join(\",\")] as const;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Generic database schema type constraint.\n * Your Supabase-generated Database type should satisfy this.\n */\nexport type DatabaseSchema = {\n  [schema: string]: {\n    Tables: {\n      [table: string]: {\n        Row: { id: string | number };\n        Insert: Record<string, unknown>;\n        Update: Record<string, unknown>;\n        Relationships: unknown[];\n      };\n    };\n    Views: Record<string, unknown>;\n    Functions: Record<string, unknown>;\n    Enums: Record<string, unknown>;\n    CompositeTypes: Record<string, unknown>;\n  };\n};\n\n/**\n * Extract table names from a schema\n */\nexport type TableNames<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase = \"public\"\n> = keyof TDatabase[TSchema][\"Tables\"] & string;\n\n/**\n * Extract row type for a table\n */\nexport type TableRow<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n> = TDatabase[TSchema][\"Tables\"][TTable][\"Row\"];\n\n/**\n * Extract insert type for a table\n */\nexport type TableInsert<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n> = TDatabase[TSchema][\"Tables\"][TTable][\"Insert\"];\n\n/**\n * Extract update type for a table\n */\nexport type TableUpdate<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n> = TDatabase[TSchema][\"Tables\"][TTable][\"Update\"];\n\n/**\n * Extract the ID type for a table\n */\nexport type TableID<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n> = TableRow<TDatabase, TSchema, TTable>[\"id\"];\n\n/**\n * Realtime event types\n */\nexport type RealtimeEvent<TTable extends string, TRow extends { id: any }>\n  = | {\n    operation: \"INSERT\";\n    table: TTable;\n    record: TRow;\n  }\n  | {\n    operation: \"UPDATE\";\n    table: TTable;\n    record: TRow;\n    old_record: TRow;\n  }\n  | {\n    operation: \"DELETE\";\n    table: TTable;\n    old_record: TRow;\n  };\n\n/**\n * Sort configuration for list queries.\n * The key parameter allows type-safe access to a specific column for sorting.\n */\nexport type Sort<TRow, TKey extends keyof TRow = keyof TRow> = {\n  key: TKey;\n  comparable: (value: TRow[TKey]) => number;\n  order: \"asc\" | \"desc\";\n};\n\n/**\n * Helper to create sort configuration\n */\nexport function sort<TRow, TKey extends keyof TRow>(\n  key: TKey,\n  comparable: (value: TRow[TKey]) => number,\n  order: \"asc\" | \"desc\"\n): Sort<TRow, TKey> {\n  return { key, comparable, order };\n}\n","\"use client\";\n\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { createContext, useContext, useEffect, useState } from \"react\";\n\nimport { Repository, RepositoryConfig } from \"./repository\";\nimport { DatabaseSchema } from \"./types\";\n\n/**\n * Create a typed repository context for your database schema\n */\nexport function createRepositoryContext<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase\n>() {\n  const RepositoryContext = createContext<Repository<TDatabase, TSchema> | null>(null);\n\n  function useRepository(): Repository<TDatabase, TSchema> {\n    const context = useContext(RepositoryContext);\n    if (!context) {\n      throw new Error(\"useRepository must be used within a RepositoryProvider\");\n    }\n    return context;\n  }\n\n  function RepositoryProvider({\n    config,\n    children\n  }: {\n    config: RepositoryConfig<TDatabase, TSchema>;\n    children: React.ReactNode;\n  }) {\n    const [repository, setRepository] = useState<Repository<TDatabase, TSchema>>(\n      () => new Repository(config)\n    );\n\n    // Recreate repository when config changes (e.g., user changes)\n    useEffect(() => {\n      setRepository((current) => {\n        current.destroy();\n        return new Repository(config);\n      });\n    }, [config]);\n\n    // Cleanup on unmount\n    useEffect(() => {\n      return () => repository.destroy();\n    }, [repository]);\n\n    return (\n      <QueryClientProvider client={repository.queryClient}>\n        <RepositoryContext.Provider value={repository}>\n          {children}\n        </RepositoryContext.Provider>\n      </QueryClientProvider>\n    );\n  }\n\n  return { RepositoryContext, RepositoryProvider, useRepository };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\";\n\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport compact from \"lodash/compact\";\nimport sortBy from \"lodash/sortBy\";\nimport { useEffect, useRef } from \"react\";\n\nimport { recordListQueryKey, recordQueryKey } from \"./query-keys\";\nimport { FilterBuilder, Repository } from \"./repository\";\nimport { DatabaseSchema, Sort, TableNames, TableRow, TableUpdate } from \"./types\";\n\n/**\n * Hook to get a single record by ID with realtime updates\n */\nexport function useRecordById<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n>(\n  repository: Repository<TDatabase, TSchema>,\n  table: TTable,\n  id: TableRow<TDatabase, TSchema, TTable>[\"id\"] | null\n) {\n  return useQuery({\n    queryKey: recordQueryKey(table, id ?? \"null\"),\n    queryFn: async () => {\n      if (!id) return null;\n      return await repository.getRecordById(table, id);\n    }\n  });\n}\n\n/**\n * Hook to get multiple records by IDs with realtime updates\n */\nexport function useRecordByIds<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n>(\n  repository: Repository<TDatabase, TSchema>,\n  table: TTable,\n  ids: TableRow<TDatabase, TSchema, TTable>[\"id\"][]\n) {\n  const subscriptionRef = useRef<(() => void) | null>(null);\n\n  useEffect(() => {\n    if (ids.length === 0) return;\n\n    const unsubscribe = repository.queryClient.getQueryCache().subscribe((event) => {\n      if (event.query.queryKey[0] === table && ids.includes(event.query.queryKey[1] as any)) {\n        const cachedItems = ids\n          .map(id => repository.queryClient.getQueryData(recordQueryKey(table, id)))\n          .filter(Boolean) as TableRow<TDatabase, TSchema, TTable>[];\n\n        repository.queryClient.setQueryData(\n          [table, \"byIds\", [...ids].sort().join(\",\")],\n          cachedItems\n        );\n      }\n    });\n    subscriptionRef.current = unsubscribe;\n    return unsubscribe;\n  }, [table, repository, ids]);\n\n  return useQuery({\n    queryKey: [table, \"byIds\", ids.join(\",\")],\n    queryFn: async () => {\n      if (ids.length === 0) return [];\n\n      const itemMap = new Map<any, TableRow<TDatabase, TSchema, TTable>>();\n      const missingIds: any[] = [];\n\n      for (const id of ids) {\n        const cached = repository.queryClient.getQueryData(\n          recordQueryKey(table, id)\n        ) as TableRow<TDatabase, TSchema, TTable> | undefined;\n        if (cached) {\n          itemMap.set(id, cached);\n        } else {\n          missingIds.push(id);\n        }\n      }\n\n      if (missingIds.length > 0) {\n        const fetchedItems = await repository.getRecordByIds(table, missingIds);\n        fetchedItems.forEach((item) => {\n          const itemId = (item as any).id;\n          repository.queryClient.setQueryData(recordQueryKey(table, itemId), item);\n          itemMap.set(itemId, item);\n        });\n      }\n\n      return compact(ids.map(id => itemMap.get(id)!));\n    }\n  });\n}\n\n/**\n * Hook to get a list of records with custom query, sorting, and filtering\n */\nexport function useRecordListQuery<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n>(\n  repository: Repository<TDatabase, TSchema>,\n  table: TTable,\n  listName: string,\n  options: {\n    query: (filter: FilterBuilder<TDatabase, TSchema, TTable>) => FilterBuilder<TDatabase, TSchema, TTable>;\n    sort: Sort<TableRow<TDatabase, TSchema, TTable>, any>;\n    filter?: (item: TableRow<TDatabase, TSchema, TTable>) => boolean;\n  }\n) {\n  const queryKey = recordListQueryKey(table, listName);\n\n  const query = useQuery({\n    queryKey: queryKey,\n    queryFn: async () => await repository.getRecords(table, options.query)\n  });\n\n  useEffect(() => {\n    const unsubscribe = repository.queryClient.getQueryCache().subscribe((event) => {\n      if (event.query.queryKey[0] === table && event.query.queryKey.length === 2) {\n        if (event.type === \"removed\") {\n          repository.queryClient.setQueryData(\n            queryKey,\n            (prevData: TableRow<TDatabase, TSchema, TTable>[] | undefined) => {\n              if (!prevData) return prevData;\n              const index = prevData.findIndex(item => item.id === event.query.queryKey[1]);\n              if (index === -1) return prevData;\n              return [...prevData.slice(0, index), ...prevData.slice(index + 1)];\n            }\n          );\n        } else if (event.type === \"updated\") {\n          repository.queryClient.setQueryData(\n            queryKey,\n            (prevData: TableRow<TDatabase, TSchema, TTable>[] | undefined) => {\n              if (!prevData) return prevData;\n\n              const newRecord = event.action.type === \"success\" && event.action.data;\n              if (!newRecord) return prevData;\n\n              const map = new Map(prevData?.map(item => [item.id, item]) ?? []);\n              if (options.filter && !options.filter(newRecord as any)) {\n                map.delete((newRecord as any).id);\n              } else {\n                map.set((newRecord as any).id, newRecord as any);\n              }\n\n              return sortBy(Array.from(map.values()), [\n                (value) => {\n                  const sortConfig = options.sort;\n                  const sortValue = value[sortConfig.key as keyof typeof value];\n                  return sortConfig.comparable(sortValue as any) * (sortConfig.order === \"asc\" ? 1 : -1);\n                }\n              ]);\n            }\n          );\n        }\n      }\n    });\n    return unsubscribe;\n  }, [table, queryKey, repository, options]);\n\n  return query;\n}\n\n/**\n * Hook to update a record\n */\nexport function useUpdateRecord<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n>(repository: Repository<TDatabase, TSchema>, table: TTable) {\n  return useMutation({\n    mutationFn: async ({\n      id,\n      update\n    }: {\n      id: TableRow<TDatabase, TSchema, TTable>[\"id\"];\n      update: Partial<TableUpdate<TDatabase, TSchema, TTable>>;\n    }) => {\n      return await repository.updateRecord(table, id, update);\n    }\n  });\n}\n\n/**\n * Hook to delete a record\n */\nexport function useDeleteRecord<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n>(repository: Repository<TDatabase, TSchema>, table: TTable) {\n  return useMutation({\n    mutationFn: async (id: TableRow<TDatabase, TSchema, TTable>[\"id\"]) => {\n      return await repository.deleteRecord(table, id);\n    }\n  });\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { Observable } from \"rxjs\";\nimport { AnonymousSubject } from \"rxjs/internal/Subject\";\n\nimport { DatabaseSchema, RealtimeEvent, TableNames } from \"./types\";\n\n/**\n * Configuration for creating a realtime channel\n */\nexport type RealtimeChannelConfig<TDatabase extends DatabaseSchema> = {\n  supabase: SupabaseClient<TDatabase>;\n  channelName: string;\n  /** Whether the channel is private (requires RLS) */\n  isPrivate?: boolean;\n};\n\n/**\n * Create an Observable that emits realtime events from a Supabase broadcast channel\n *\n * The channel expects broadcast events in the format:\n * { operation: 'INSERT' | 'UPDATE' | 'DELETE', table: string, record?: {...}, old_record?: {...} }\n */\nexport function createRealtimeChannel<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase = \"public\"\n>(\n  config: RealtimeChannelConfig<TDatabase>\n): Observable<RealtimeEvent<TableNames<TDatabase, TSchema>, any>> {\n  const observable = new Observable<RealtimeEvent<TableNames<TDatabase, TSchema>, any>>((subscriber) => {\n    const channel = config.supabase\n      .channel(config.channelName, {\n        config: {\n          private: config.isPrivate ?? false\n        }\n      })\n      .on(\"broadcast\", { event: \"*\" }, ({ payload }) => {\n        subscriber.next(payload as any);\n      })\n      .subscribe();\n\n    subscriber.add(() => {\n      channel.unsubscribe();\n    });\n  });\n\n  return new AnonymousSubject(undefined, observable);\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { SupabaseClient } from \"@supabase/supabase-js\";\nimport { QueryClient } from \"@tanstack/react-query\";\n\nimport { recordQueryKey } from \"./query-keys\";\nimport { DatabaseSchema, TableNames, TableRow } from \"./types\";\n\n/**\n * Prefetch a record by ID for server-side rendering\n */\nexport async function prefetchRecordById<\n  TDatabase extends DatabaseSchema,\n  TSchema extends keyof TDatabase,\n  TTable extends TableNames<TDatabase, TSchema>\n>(\n  queryClient: QueryClient,\n  supabase: SupabaseClient<TDatabase>,\n  schema: TSchema,\n  table: TTable,\n  id: TableRow<TDatabase, TSchema, TTable>[\"id\"]\n) {\n  return queryClient.prefetchQuery({\n    queryKey: recordQueryKey(table, id),\n    queryFn: async () => {\n      const res = await (supabase as any)\n        .schema(schema)\n        .from(table)\n        .select()\n        .eq(\"id\", id)\n        .maybeSingle();\n      if (res.error) throw res.error;\n      return res.data;\n    }\n  });\n}\n"],"mappings":"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","names":["import_react_query","import_react_query","import_react","compact","sortBy"]}